# -*- coding: UTF-8 -*-
import subprocess
import tempfile
import re
import numpy as np
import time
import sys
import math
import os
import getpass

# -----------------------------------------
# input: start location & destination
# output: task plan, whose format is [inlane_list_name, cost, cost + succ, merge_lane_or_not]
# -----------------------------------------

start_loc = "x=" + str(sys.argv[1])  # input
dest_loc = "y=" + str(sys.argv[2])

start_time = time.time()  # to compute time cost of asp solver

carla_version = 'CARLA_0.9.10.1'
address1 = '/home/' + getpass.getuser() + '/' + carla_version + '/PythonAPI/TMPUD/interaction/' # folder 'interaction' is shared
address2 = '/home/' + getpass.getuser() + '/' + carla_version + '/PythonAPI/TMPUD/task-level/'
plans_list = []  # store all plans, and their format: [inlane_list_name, cost, cost + succ, merge_lane_or_not]

with tempfile.TemporaryFile() as tempf:
    # -----------------------------------------
    # compute a task plan via asp
    # n=10 stands for #num of steps
    # '-n' '0' stands for output all feasible plans
    # facts.asp, problem.asp, ruleDriving.asp are knowledge generated by human
    # -----------------------------------------
    proc = subprocess.Popen(
        ['clingo', address2+'facts.asp', address2+'problem.asp', address2+'rulesDriving.asp', '-c', 'n=10', '-c', start_loc, '-c', dest_loc, '-n',
         '0'], stdout=tempf)
    proc.wait()
    tempf.seek(0)
    for line in tempf:
        line = line.decode('utf-8')  # each line is an output plan
        if line.find('inlane') != -1:
            # line format: inlane(37,0) inlane(47,4) stop(4) stop(5) stop(6) stop(7) stop(8) stop(9) inlane(38,
            # 1) changeleft(0) inlane(83,2) turnleft(1) turnleft(2) inlane(139,3) turnright(3) stop(10)
            # inline_list format: ['inlane(37,0)', 'inlane(47,4)', 'inlane(38,1)', 'inlane(83,2)', 'inlane(139,3)']
            inlane_list = re.findall(r'inlane[(]\d+[,]\d+[)]', line)

            changeleft_list = re.findall(r'changeleft[(]\d+[)]', line)
            changeright_list = re.findall(r'changeright[(]\d+[)]', line)
            turnleft_list = re.findall(r'turnleft[(]\d+[)]', line)
            turnright_list = re.findall(r'turnright[(]\d+[)]', line)
            forward_list = re.findall(r'forward[(]\d+[)]', line)
            stop_list = re.findall(r'stop[(]\d+[)]', line)

            action_list = changeleft_list + changeright_list + turnleft_list + turnright_list + forward_list + stop_list

            num_change = len(changeleft_list) + len(changeright_list)
            num_turn = len(turnleft_list) + len(turnright_list)

            inlane_list_name_step = []
            # inlane_list_name_step format: [['inlane', '37', '0'], ['inlane', '47', '4'], ['inlane', '38', '1'],
            # ['inlane', '83', '2'], ['inlane', '139', '3']]
            for item_inlane in inlane_list:
                Lane_name_step = re.findall(r'\d+', item_inlane)
                lane_name = Lane_name_step[0]
                lane_step = Lane_name_step[1]
                inlane_list_name_step.append(['inlane', lane_name, lane_step])
            inlane_list_name_step_sorted = []  # need to sort inlane_list_name_step
            for i in range(len(inlane_list_name_step)):
                for j in range(len(inlane_list_name_step)):
                    if i == int(inlane_list_name_step[j][2]):
                        inlane_list_name_step_sorted.append(inlane_list_name_step[j])
            inlane_list_name_step = inlane_list_name_step_sorted

            action_list_step = []
            # action_list_step format: [['changeleft', '0'], ['turnleft', '1'], ['turnleft', '2'], ['turnright',
            # '3'], ['stop', '4'], ['stop', '5'], ['stop', '6'], ['stop', '7'], ['stop', '8'], ['stop', '9'],
            # ['stop', '10']]
            for item_action in action_list:
                Action = re.findall(r'[a-z]+', item_action)
                Action = ''.join(Action)
                Step = re.findall(r'\d+', item_action)
                Step = ''.join(Step)
                action_list_step.append([Action, Step])
            action_list_step_sorted = []  # need to sort action_list_step
            for i in range(len(action_list_step)):
                for j in range(len(action_list_step)):
                    if i == int(action_list_step[j][1]):
                        action_list_step_sorted.append(action_list_step[j])
            action_list_step = action_list_step_sorted

            # -----------------------------------------
            # compute risk value of a task plan
            # here only consider the risk value of merge_left or merge_right
            # -----------------------------------------
            merge_lane_or_not = []

            plans_succ = []  # store risk value of all task plans
            each_plan_succ = 0  # initialize risk value of a task plan

            plans_cost = []  # store cost value of all task plans
            each_plan_cost = 0  # initialize cost value of a task plan

            with open(address1 + 'lanes_risk.txt') as f:  # read risk value of each lane
                risk_data = [line.rstrip() for line in f]

            for item_inlane in inlane_list_name_step:  # compute risk value of a task
                lane_name = item_inlane[1]
                lane_step = item_inlane[2]
                for item_action in action_list_step:
                    if lane_step == item_action[1]:
                        lane_action = item_action[0]
                        target_str = 'inlane_' + lane_action + '(' + lane_name + ')'
                        risk = int(risk_data[risk_data.index(target_str) + 1])
                        each_plan_succ = each_plan_succ + 2500 / (math.exp(- risk / 100) + 1) - 2500 / (math.exp(0) + 1)
                        if lane_action == 'changeleft' or lane_action == 'changeright':
                            merge_lane_or_not.append(1)
                        else:
                            merge_lane_or_not.append(0)

            with open(address1 + 'lanes_cost.txt') as f:  # read cost value of each lane
                cost_data = [line.rstrip() for line in f]

            for item_inlane in inlane_list_name_step:  # compute cost value of a task
                lane_name = item_inlane[1]
                lane_step = item_inlane[2]
                target_str = 'inlane' + '(' + lane_name + ')'
                cost = int(cost_data[cost_data.index(target_str) + 1])
                for item_action in action_list_step:
                    if lane_step == item_action[1]:
                        lane_action = item_action[0]
                        if lane_action == 'changeleft' or lane_action == 'changeright':
                            cost = 0
                each_plan_cost = each_plan_cost + cost
            each_plan_cost = each_plan_cost + num_turn * 25

            inlane_list_name = []
            temp = []
            for inlane in inlane_list_name_step:
                temp.append(int(inlane[1]))
            inlane_list_name.append(temp)
            inlane_list_name.append(each_plan_cost)
            # -----------------------------------------
            # trade off between cost and risk and get a new value
            # -----------------------------------------
            inlane_list_name.append(each_plan_succ + each_plan_cost)
            inlane_list_name.append(merge_lane_or_not)
            plans_list.append(inlane_list_name)


# -----------------------------------------
# output the plan that has the minimal cost and maximum succ.
# -----------------------------------------
def takeSecond(elem):
    return elem[1]


def takeThird(elem):
    return elem[2]


plans_list.sort(key=takeSecond)
mini_distance = int(plans_list[0][1])
part_plans_info = []
for plan in plans_list:  # select plan with proper distance
    allowed_distance = mini_distance * 100
    if int(plan[1]) <= allowed_distance:
        part_plans_info.append(plan)
part_plans_info.sort(key=takeThird, reverse=False)
output_plan = part_plans_info[0]
print('optimal task plan: %s \n' % output_plan)

print('--- computing task plan needs %.3f seconds ---\n' % (time.time() - start_time))

np.save(address1 + "task_plan.npy", output_plan)